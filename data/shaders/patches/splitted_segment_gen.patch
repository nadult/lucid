diff --git a/data/shaders/raster_bin_fastest.shader b/data/shaders/raster_bin_fastest.shader
index 28d767c..7787067 100644
--- a/data/shaders/raster_bin_fastest.shader
+++ b/data/shaders/raster_bin_fastest.shader
@@ -666,14 +666,14 @@ void generateBlocks(uint bid) {
 	// Also finding first triangle for each segment
 	uint src_offset_32 = dst_offset_32;
 	src_offset_64 = dst_offset_64;
-	dst_offset_64 = scratch64HalfBlockTrisOffset(lbid << 1);
 
-	uint seg_block1_offset = lbid << (MAX_SEGMENTS_SHIFT + 1);
-	uint seg_block2_offset = seg_block1_offset + MAX_SEGMENTS;
+	uint hbid = (LIX >> 4) & 1, half_shift = hbid * 12;
+	uint seg_block_offset = (lbid << (MAX_SEGMENTS_SHIFT + 1)) + (hbid << MAX_SEGMENTS_SHIFT);
+	dst_offset_64 = scratch64HalfBlockTrisOffset(lbid << 1) + (hbid << MAX_BLOCK_TRIS_SHIFT);
 
-	// TODO: split this loop into two
-	for(uint i = LIX & WARP_MASK; i < tri_count; i += WARP_STEP) {
+	for(uint i = LIX & (WARP_MASK >> 1); i < tri_count; i += WARP_STEP / 2) {
 		uint tri_offset = 0;
+		// TODO: do this once and use shuffle? but how?
 		if(i > 0) {
 			uint prev = i - 1;
 			tri_offset = s_buffer[buf_offset + prev] & 0xffffff;
@@ -683,33 +683,22 @@ void generateBlocks(uint bid) {
 		uint tri_value = s_buffer[buf_offset + i] + s_mini_buffer[(lbid << 3) + (i >> 5)];
 		uint tile_tri_idx = tri_value >> 24;
 		tri_value = (tri_value & 0xffffff) - tri_offset;
-
-		uint tri_offset0 = tri_offset & 0xfff, tri_offset1 = (tri_offset >> 12) & 0xfff;
-		uint tri_value0 = tri_value & 0xfff, tri_value1 = (tri_value >> 12) & 0xfff;
-
-#define FILL_SEGMENT(tri_offset, tri_value, base)                                                  \
-	{                                                                                              \
-		uint seg_id = tri_offset >> SEGMENT_SHIFT;                                                 \
-		if(tri_value > 0) {                                                                        \
-			uint seg_offset = tri_offset & (SEGMENT_SIZE - 1);                                     \
-			uint value = i + 1;                                                                    \
-			if(seg_offset == 0)                                                                    \
-				s_segments[base + seg_id] = value;                                                 \
-			else if(seg_offset + tri_value > SEGMENT_SIZE)                                         \
-				s_segments[base + seg_id + 1] = value;                                             \
-		}                                                                                          \
-	}
-		FILL_SEGMENT(tri_offset0, tri_value0, seg_block1_offset);
-		FILL_SEGMENT(tri_offset1, tri_value1, seg_block2_offset);
-
-#undef FILL_SEGMENT
+		tri_offset = (tri_offset >> half_shift) & 0xfff;
+		tri_value = (tri_value >> half_shift) & 0xfff;
+
+		uint seg_id = tri_offset >> SEGMENT_SHIFT;
+		if(tri_value > 0) {
+			uint seg_offset = tri_offset & (SEGMENT_SIZE - 1);
+			uint value = i + 1;
+			if(seg_offset == 0)
+				s_segments[seg_block_offset + seg_id] = value;
+			else if(seg_offset + tri_value > SEGMENT_SIZE)
+				s_segments[seg_block_offset + seg_id + 1] = value;
+		}
 
 		uint tri_idx = g_scratch_32[src_offset_32 + tile_tri_idx] & 0xffff;
-		uvec2 tri_data = g_scratch_64[src_offset_64 + tile_tri_idx];
-
-		g_scratch_64[dst_offset_64 + i] = uvec2(tri_idx | (tri_offset0 << 16), tri_data.x);
-		g_scratch_64[dst_offset_64 + i + MAX_BLOCK_TRIS] =
-			uvec2(tri_idx | (tri_offset1 << 16), tri_data.y);
+		uint tri_data = g_scratch_64[src_offset_64 + tile_tri_idx][hbid];
+		g_scratch_64[dst_offset_64 + i] = uvec2(tri_idx | (tri_offset << 16), tri_data);
 	}
 	barrier();
 
@@ -1129,6 +1118,7 @@ void rasterBin(int bin_id) {
 		}
 		UPDATE_CLOCK(1);
 
+		// TODO: simplify handling of half block
 		int bid = fbid + int(LIX >> 6), hbid = int((LIX >> 5) & 1);
 		int frag_count = int((s_block_frag_count[bid & (NUM_WARPS - 1)] >> (hbid << 4)) & 0xffff);
 		int segment_id = 0;